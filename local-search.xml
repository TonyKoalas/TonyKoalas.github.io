<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kafka-参数</title>
    <link href="/2021/08/31/Kafka/Kafka-%E5%8F%82%E6%95%B0/"/>
    <url>/2021/08/31/Kafka/Kafka-%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="关键Parameter说明"><a href="#关键Parameter说明" class="headerlink" title="关键Parameter说明"></a>关键Parameter说明</h4><h5 id="max-poll-interval-ms"><a href="#max-poll-interval-ms" class="headerlink" title="max.poll.interval.ms"></a>max.poll.interval.ms</h5><ol><li>定义<br>表示最大的poll数据间隔</li><li>影响<br><u><strong>如果超过这个间隔没有发起poll请求,该consumer会退出consumer group,Coordinator会开始rebalance</strong></u></li></ol><h5 id="max-partition-fetch-bytes"><a href="#max-partition-fetch-bytes" class="headerlink" title="max.partition.fetch.bytes"></a>max.partition.fetch.bytes</h5><ol><li>定义<br>限制每次从kafka中fetch的record的大小,并放到本地缓存中</li><li>影响<br>待缓存中的数据全被poll完才可进行下一次的fetch</li></ol><h5 id="max-poll-records"><a href="#max-poll-records" class="headerlink" title="max.poll.records"></a>max.poll.records</h5><ol><li>定义<br>限制每次从缓存中poll出来的record数量</li><li>影响<br>无</li></ol><h5 id="heartbeat-interval-ms"><a href="#heartbeat-interval-ms" class="headerlink" title="heartbeat.interval.ms"></a>heartbeat.interval.ms</h5><ol><li>定义<br>consumer与coordinator之间的心跳，默认3秒。<br>通常设定为session.timeout.ms的1/3</li><li>影响<br>无</li></ol><h5 id="session-timeout-ms"><a href="#session-timeout-ms" class="headerlink" title="session.timeout.ms"></a>session.timeout.ms</h5><ol><li>定义<br>consumer session的过期时间，默认10秒</li><li>影响<br>如果无心跳的时间超过session.timeout.ms</li></ol>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka-初识</title>
    <link href="/2021/08/15/Kafka/Kafka-%E5%88%9D%E8%AF%86/"/>
    <url>/2021/08/15/Kafka/Kafka-%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h4 id="Kafka集群架构"><a href="#Kafka集群架构" class="headerlink" title="Kafka集群架构"></a>Kafka集群架构</h4><img src="/images/kafka.jpg"><p><code>备注：从2.8版本开始，可使用Kafka内部的Quorum控制器来取代ZooKeeper</code></p><img src="/images/zookeeper.jpg"><h4 id="Kafka在系统中的作用"><a href="#Kafka在系统中的作用" class="headerlink" title="Kafka在系统中的作用"></a>Kafka在系统中的作用</h4><ul><li>模块间解耦</li><li>冗余：可以将数据持久化保留一段时间</li><li>扩展性：水平扩展（增加服务器数量），垂直扩展（增加topic，partition等等）</li><li>灵活性，峰值处理能力</li><li>恢复性:部分模块暂时性挂掉，不会影响其他系统工作；一旦模块恢复，可继续对队列中的消息进行处理</li><li>顺序保证：一个partition内的消息的有序性</li><li>缓冲，异步操作</li></ul><h4 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h4><ul><li>ISR(In Sync Replica):“不丢消息”机制</li><li>ack机制:producer的消息发送确认机制</li><li>rebalance</li><li>controller:kafka集群中一个节点，用来进行leader election以及各种failover</li><li>Deliver guarantee：消息传递保障</li></ul><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><ol><li>写入方式<br>producer发布消息到broker，消息会被append到对应的partition中，每个partition对应一个append.log文件，每一条message会被追加到log文件的尾部，在文件中的位置称做offset。message写入属于顺序写磁盘（<strong>顺序写磁盘效率比随机写内存还要高</strong>），这也是kafka的高吞吐率的保证</li><li>业务流程</li></ol><ul><li>异步处理：main thread发送给recored accumulator就返回，当缓冲队列达到一定条件就通过sender线程发送给broker。</li><li><strong>可以指定partition；<br>可以通过key进行hash选一个partition；<br>如果partition和key都为null，轮询选出一个partition。</strong></li><li>batch.size：控制缓存队列里batch的大小<br>acks：关乎高吞吐和持久性的参数，值可为0，-1，1<br>retries:重试机制</li><li>一个batch只对应一个topic的一个partition；由于size限制，一个partiton可能有多个batch</li><li>一个batch包括compressor压缩器，缓冲区，thunks（回调逻辑的集合）</li><li>Sender线程轮询缓冲区，并把获取到的batch按照目标分区所在的broker进行分组，通过socket发送给broker</li><li>一旦Sender线程接收到response将依次(按照消息发送顺序)调用batch中的回调方法</li><li>KafkaProducer是线程安全的（可以所有线程共享一个KafkaProducer实例）</li></ul><p><code>调优producer前我们就需要搞清楚性能瓶颈到底是在用户主线程还是在Sender线程</code></p><img src="/images/producer1.jpg">3. 时序图* producer先从zookeeper的"/brokers/.../state"节点找到该partition的leader* producer将消息发送给该leader* leader将消息写入本地log* followers从leader pull消息，写入本地log后向leader发送ACK* leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK<img src="/images/producer2.jpg">4. ACKS* acks=0:只要把消息发送出去,就认为成功了* acks=1:默认值，partition leader 收到消息并落地，则认为成功* acks=-1(all):partiton leader收到消息并落地，ISR里的所有follower同步了消息，则认为成功<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><ol><li>Consumer和Group的关系<br>一个Group可能有多个consumer</li><li>Poll</li></ol><ul><li>Consumer通过poll方法来消费kafka的数据</li><li>poll方法发起fetch请求从kafka读取数据，max.partition.fetch.bytes决定每次读取的量，fetch到的数据会放在本地缓存中</li><li>如果缓存中还有未被消费的数据，poll方法会优先获取缓存中的数据(size由max.poll.records决定)，待全部消费完才会发起下一次的fetch请求<img src="/images/poll.jpg"></li></ul><ol start="3"><li>commit offset</li></ol><ul><li>enable.auto.commit：自动提交，手动提交</li><li>auto.offset.reset：<br>earliest-重置到最早的offset<br>latest-重置到最新的offset</li></ul><h4 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h4><ol><li>触发条件</li></ol><ul><li>group成员数量变动</li><li>订阅的topic个数发生变化</li><li>订阅的topic的分区数发生变化</li></ul><ol start="2"><li>Rebalance过程</li></ol><ul><li>Heartbeat:consumer和coordinator之间的心跳，心跳周期可配（默认10秒）</li><li>JoinGroup:加入group，确定group leader</li><li>SyncGroup:leader分配消费方案<img src="/images/rebalance1.jpg"><img src="/images/rebalance2.jpg"><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">特别注意：<br>max<span class="hljs-selector-class">.poll</span><span class="hljs-selector-class">.interval</span>.ms：Consumer两次调用 poll 方法的最大时间间隔，默认是<span class="hljs-number">5</span>minutes。<br>如果Consumer如果在<span class="hljs-number">5</span>分钟之内无法消费完 poll 方法返回消息，那么Consumer会主动发起 “离开组” 的请求，Coordinator 也会开启新一轮 Rebalance。<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>Coordinator</li></ol><ul><li>Group Coordinator是用来存储group的meta信息，以及group的topic的partition的offset信息</li><li>记录再kafka的topic(__consumer_offsets)，该topic的分区默认为50个</li><li>每个broker上都会有一个Group Coordinator服务</li><li>每个group如何选择一个Coordinator：<br>(1)根据groupid找到__consumer_offsets上对应的partition<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">计算groupid的hash值,对<span class="hljs-number">50</span>取余得出<span class="hljs-number">0</span>-<span class="hljs-number">49</span>的值<br>partition-<span class="hljs-constructor">Id(<span class="hljs-params">__consumer_offsets</span>)</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(groupId.hash<span class="hljs-constructor">Code()</span> % groupMetadataTopicPartitionCount)<br></code></pre></td></tr></table></figure>(2)根据该partition的leader所对应的broker，即可确定Coordinator<img src="/images/coordinator.jpg"><img src="/images/coordinator2.jpg"></li></ul><p><code>https://www.cnblogs.com/xifenglou/p/7251112.html https://www.jianshu.com/p/46cb44c6b96c https://www.cnblogs.com/yoke/p/11405397.html https://blog.csdn.net/u012129558/article/details/80076327 </code></p>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-初识</title>
    <link href="/2021/07/26/Redis/Redis-%E5%88%9D%E8%AF%86/"/>
    <url>/2021/07/26/Redis/Redis-%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Redis的IO多路复用</p><ul><li>多路指的是多个网络连接（socket），复用指的是复用同一个线程处理数据</li><li>IO多路复用程序会同时监听多个socket，当被监听的socket准备好执行accept、read、write、close等操作时，与这些操作相对应的文件事件就会产生。IO多路复用程序会把所有产生事件的socket压入一个队列中，然后有序地每次仅一个socket的方式传送给文件事件分派器，文件事件分派器接收到socket之后会根据socket产生的事件类型调用对应的事件处理器进行处理。</li><li><strong>Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行</strong></li></ul><img src="/images/Redis.jpg"></li></ol><p>参考：</p><ul><li><a class="link"   href="https://www.cnblogs.com/mumage/p/12832766.html" >https://www.cnblogs.com/mumage/p/12832766.html<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/reecelin/p/13538382.html" >https://www.cnblogs.com/reecelin/p/13538382.html<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/reecelin/p/13537734.html" >https://www.cnblogs.com/reecelin/p/13537734.html<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis Sentinel-哨兵模式</title>
    <link href="/2021/07/16/Redis/Redis-Sentinel%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/16/Redis/Redis-Sentinel%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>架构图</p><img src="/images/RedisSentinels.jpg"></li><li><p>几个关键概念</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">（<span class="hljs-number">1</span>）主观下线(Subjectively Down)：简称S_DOWN；<br>（<span class="hljs-number">2</span>）客观下线(Objectively Down)：简称O_DOWN；<br>（<span class="hljs-number">3</span>）quorum：确认odown的最少的哨兵数量；<br>（<span class="hljs-number">4</span>）down-after-milliseconds：在该时间范围内没有相应pong，则认为<span class="hljs-literal">master</span>主观下线；<br>（<span class="hljs-number">5</span>）PING命令和PONG命令：判断是否标记<span class="hljs-literal">master</span>为主观下线； <br>（<span class="hljs-number">6</span>）<span class="hljs-literal">INF</span>O命令：获取主从关系变化，查看<span class="hljs-literal">master</span>的配置信息；<br>（<span class="hljs-number">7</span>）majority：授权进行主从切换(failover)的最少的哨兵数量<br>（<span class="hljs-number">8</span>）failover：故障迁移<br>（<span class="hljs-number">9</span>）sentinel_hello：发布/订阅的频道，进行failover的sentinel会将新配置广播给其他的sentinel<br></code></pre></td></tr></table></figure></li><li><p>几个关键条件</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">（1）2个哨兵的<span class="hljs-attribute">majority</span>=2，3个哨兵的majority=2，4个哨兵的majority=3，5个哨兵的majority=3)<br>（2）当quorum&lt;majority时，quorum确定odown，majority确定failover<br>（3）当quorum&gt;=majority时,quorum确定odown和failover(?待测试)<br>（4）sentinels的存活数一定要大于等于配置的quorum<br></code></pre></td></tr></table></figure></li><li><p>Sentinel监视流程</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">（<span class="hljs-number">1</span>）sentinel跟所有的instances建立连接（包括sentinels、<span class="hljs-literal">master</span>、<span class="hljs-literal">slave</span>）。<br>（<span class="hljs-number">2</span>）每个sentinel每秒向所有的instances发送ping命令，收到回应（pong，loading，masterdown）；如果在down-after-milliseconds没有得到回应，则标记sdown。<br>（<span class="hljs-number">3</span>）每个sentinel每<span class="hljs-number">10</span>秒向主从服务器发送<span class="hljs-literal">inf</span>o命令；(如果主被odown，则频率会变成每秒)。<br>（<span class="hljs-number">4</span>）如果认同sdown的sentinel数量达到quorum的值，则标记主为odown<br></code></pre></td></tr></table></figure></li><li><p>服务发现：通过发布/订阅功能来实现的</p><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">（<span class="hljs-number">1</span>）主从都有自己的sentinel:hello频道<br>（<span class="hljs-number">2</span>）sentinel每<span class="hljs-number">2</span>秒向频道发送信息：sentinel的<span class="hljs-built_in">ip</span>地址，端口号，runid<br>（<span class="hljs-number">3</span>）在频道中发现新的sentinel信息，会将其更新到自己的sentinels列表中（会比较<span class="hljs-built_in">ip</span>，端口，runid来确定是更新还是新增）<br>（<span class="hljs-number">4</span>）sentinel还会发送完整的主服务器的配置，如果一个sentinel收到的配置版本更新，则立马升级到新配置<br></code></pre></td></tr></table></figure></li><li><p>Sentinels领导者选举：一半以上的sentinel是同意</p></li><li><p>故障迁移（failover）</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">（<span class="hljs-number">1</span>）对从服务器进行过滤，确认最终有效的可以参与被选举的从服务器列表<br>（<span class="hljs-number">2</span>）选出<span class="hljs-keyword">replication</span> <span class="hljs-keyword">offset</span>最大的从服务器作为新主服务器；如果<span class="hljs-keyword">replication</span> <span class="hljs-keyword">offset</span>相同，则选用runid最小的<br>（<span class="hljs-number">3</span>）向该从服务器发送SLAVEOF <span class="hljs-keyword">NO</span> ONE命令，让它变成新的主服务器<br>（<span class="hljs-number">4</span>）通过发布/订阅功能（sentinel:hello频道），让其他sentinel更新配置<br>（<span class="hljs-number">5</span>）向其他从服务器发送SLAVEOF 命令，让它们去复制新的主服务器<br></code></pre></td></tr></table></figure></li><li><p>常见问题<br>(1) </p><ul><li><p>异步复制导致数据丢失：有可能部分还没来得及复制到slave就宕机了，此时这些部分数据就丢失了。</p></li><li><p>集群脑裂导致数据丢失：master所在机器突然脱离了正常的网络，跟其它slave机器不能连接，但是实际上master还运行着，此时可能会产生2个master；当网络恢复，旧master会变成slave，数据丢失。<br>解决方法：要求至少有一个slave，数据复制和同步的延迟不能超过10s；一旦超过1个，master就不会再接收任何请求了</p></li></ul>  <figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>(2) 集群不可用：</p><ul><li>存活的sentinels &lt; quorum</li><li>sentinel挂掉一半</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-interface</title>
    <link href="/2021/07/16/go%E5%9F%BA%E7%A1%80/06%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/07/16/go%E5%9F%BA%E7%A1%80/06%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2Fb57c9724cf9167764d0eaf2abc402031.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1623949493&t=362c1a0f03eb1f6eee0a66d2076fe3fe" width="400px" height="150px" style="box-shadow: 0 0 0px"><ol><li>接口的定义<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">接口名 </span><span class="hljs-keyword">interface</span> &#123;<br>    方法名<span class="hljs-number">1</span>（参数）（返回值）<br>    方法名<span class="hljs-number">2</span>（参数）（返回值）<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li>接口的实现<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">一个变量如果实现了接口中规定的所有方法，那么这个变量就实现了这个接口，可以称为这个接口类型的变量<br></code></pre></td></tr></table></figure></li><li>Demo<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> &#123;<br>    speak()<br>    eat(<span class="hljs-keyword">string</span>)<br>    <br>&#125;<br><br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>  &#123;<br>    fmt.Println(<span class="hljs-string">&quot;喵喵喵&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span> <span class="hljs-title">eat</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span>  &#123;<br>    fmt.Println(<span class="hljs-string">&quot;猫吃&quot;</span> + s)<br>&#125;<br><br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dog)</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>  &#123;<br>    fmt.Println(<span class="hljs-string">&quot;汪汪汪&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span>  &#123;<br>    fmt.Println(<span class="hljs-string">&quot;狗吃&quot;</span> + s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    <span class="hljs-keyword">var</span> a animal<br>    c := cat&#123;&#125;<br>    a=c<br>    a.eat(<span class="hljs-string">&quot;fish&quot;</span>)<br>    a.speak()<br>    <br>    d := dog&#123;&#125;<br>    d.eat(<span class="hljs-string">&quot;chicken&quot;</span>)<br>    d.speak()<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用值接收者实现接口与使用指针接收者实现接口的区别<figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang">使用值接收者实现接口:结构体类型和结构体指针类型的变量都能存.<br>使用指针接收者实现接口:只能存结构体指针类型的变量.<br></code></pre></td></tr></table></figure></li><li>接口与类型的关系<ul><li>多个类型可以实现同一个接口.</li><li><strong>==一个类型可以实现多个接口==.</strong></li><li><strong>==接口可以嵌套==.</strong><br>(看起来Go语言把java的继承和接口整合了)</li></ul></li><li>多实现和嵌套Demo<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> brid <span class="hljs-keyword">interface</span> &#123;<br>    speaker<br>    eater<br>&#125;<br><br><span class="hljs-keyword">type</span> speaker <span class="hljs-keyword">interface</span> &#123;<br>    speak()<br>&#125;<br><br><span class="hljs-keyword">type</span> eater <span class="hljs-keyword">interface</span> &#123;<br>    eat(<span class="hljs-keyword">string</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> yingwu <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y yingwu)</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>  &#123;<br>    fmt.Println(<span class="hljs-string">&quot;叽叽喳喳&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y yingwu)</span> <span class="hljs-title">eat</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span>  &#123;<br>    fmt.Println(<span class="hljs-string">&quot;鹦鹉吃&quot;</span> + s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    <span class="hljs-keyword">var</span> a brid<br>    c := &amp;yingwu&#123;&#125;<br>    a=c<br>    a.eat(<span class="hljs-string">&quot;rice&quot;</span>)<br>    a.speak()<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-struct</title>
    <link href="/2021/05/25/go%E5%9F%BA%E7%A1%80/05%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2021/05/25/go%E5%9F%BA%E7%A1%80/05%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2Fb57c9724cf9167764d0eaf2abc402031.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1623949493&t=362c1a0f03eb1f6eee0a66d2076fe3fe" width="400px" height="150px" style="box-shadow: 0 0 0px"><ol><li><p>自定义类型</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> myInt <span class="hljs-built_in">int</span> <span class="hljs-comment">//自定义类型</span><br>func main<span class="hljs-literal">()</span>  &#123;<br>   var n myInt<br>   n = <span class="hljs-number">100</span><br>   fmt.<span class="hljs-constructor">Println(<span class="hljs-params">n</span>)</span> <span class="hljs-comment">//100</span><br>   fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-params">n</span>)</span> <span class="hljs-comment">//main.myInt</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>类型别名</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> yourInt = <span class="hljs-built_in">int</span> <span class="hljs-comment">//类型别名</span><br>func main<span class="hljs-literal">()</span>  &#123;<br>   var m yourInt<br>   m = <span class="hljs-number">100</span><br>   fmt.<span class="hljs-constructor">Println(<span class="hljs-params">m</span>)</span> <span class="hljs-comment">//100</span><br>   fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-params">m</span>)</span> <span class="hljs-comment">//int</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>rune就是int32的类型别名，二者视为同一类型<br><span class="hljs-keyword">func</span> main()  &#123;<br>   var c rune <span class="hljs-regexp">//</span>类型别名<br>   c = <span class="hljs-string">&#x27;中&#x27;</span><br>   fmt.Println(c) <span class="hljs-regexp">//</span><span class="hljs-number">20013</span><br>   fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, c) <span class="hljs-regexp">//i</span>nt32<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结构体定义</p><figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> 类型名 struct &#123;<br>    字段名 字段类型<br>    字段名 字段类型<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一</li><li>字段类型：表示结构体字段的具体类型</li></ul></li><li><p>结构体Demo</p><p>==go语言函数传参永远是copy==</p><p>==如果要修改参数的值，应该使用指针型参数==</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">type person struct &#123;<br>    name string<br>    gender string<br>    hobby <span class="hljs-selector-attr">[]</span>string<br>&#125;<br>func s1(x person) &#123;<br>    x<span class="hljs-selector-class">.gender</span> = <span class="hljs-string">&quot;woman&quot;</span> <span class="hljs-comment">//修改的是副本的gender</span><br>    fmt<span class="hljs-selector-class">.Println</span>(x) <span class="hljs-comment">//&#123;威风凌人 woman []&#125;</span><br>&#125;<br>func <span class="hljs-selector-tag">main</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> person<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.name</span> = <span class="hljs-string">&quot;威风凌人&quot;</span><br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.gender</span> = <span class="hljs-string">&quot;Male&quot;</span><br>    s1(p)<br>    fmt<span class="hljs-selector-class">.Println</span>(p) <span class="hljs-comment">//&#123;威风凌人 Male []&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">type person struct &#123;<br>    name string<br>    gender string<br>    hobby <span class="hljs-selector-attr">[]</span>string<br>&#125;<br>func s2(x *person) &#123;<br>    x<span class="hljs-selector-class">.gender</span> = <span class="hljs-string">&quot;woman&quot;</span> <span class="hljs-comment">//语法糖，相当于(*x).gender</span><br>    fmt<span class="hljs-selector-class">.Println</span>(*x) <span class="hljs-comment">//&#123;威风凌人 woman []&#125;</span><br>&#125;<br>func <span class="hljs-selector-tag">main</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> person<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.name</span> = <span class="hljs-string">&quot;威风凌人&quot;</span><br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.gender</span> = <span class="hljs-string">&quot;Male&quot;</span><br>    s2(p)<br>    fmt<span class="hljs-selector-class">.Println</span>(p) <span class="hljs-comment">//&#123;威风凌人 woman []&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>匿名结构体Demo</p><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//多用于临时场景</span><br><span class="hljs-keyword">var</span> s <span class="hljs-keyword">struct</span> &#123;<br>    name,gender <span class="hljs-built_in">string</span><br>&#125;<br>s.name = <span class="hljs-string">&quot;威风凌人&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>指针类型结构体</p> <figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">var p2 = <span class="hljs-keyword">new</span>(person)<br>p2.name = <span class="hljs-string">&quot;威风凌人&quot;</span><br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-params">p2</span>)</span> <span class="hljs-comment">// *main.person  指针类型</span><br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, <span class="hljs-params">p2</span>)</span> <span class="hljs-comment">//p2保存的值，就是一个内存地址</span><br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-operator">*</span><span class="hljs-params">p2</span>)</span> <span class="hljs-comment">//main.person</span><br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, <span class="hljs-operator">*</span><span class="hljs-params">p2</span>)</span> <span class="hljs-comment">//根据p2保存的值找到的对象</span><br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;<span class="hljs-params">p2</span>)</span> <span class="hljs-comment">//p2的内存地址</span><br></code></pre></td></tr></table></figure> <figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//key-value初始化</span><br>var p3 = <span class="hljs-variable">&amp;person</span>&#123;<br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;威风凌人&quot;</span>,<br><span class="hljs-symbol">    gender:</span> <span class="hljs-string">&quot;Male&quot;</span>,<br>&#125;<br><span class="hljs-comment">//值列表的形式初始化，要注意字段顺序</span><br>var p4 = <span class="hljs-variable">&amp;person</span>&#123;<br>    <span class="hljs-string">&quot;威风凌人&quot;</span>,<br>    <span class="hljs-string">&quot;Male&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结构体占用一块连续的内存空间</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> x <span class="hljs-keyword">struct</span> &#123;<br>   a <span class="hljs-keyword">int8</span><br>   b <span class="hljs-keyword">int8</span><br>   c <span class="hljs-keyword">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>   m := x&#123;<br>      <span class="hljs-keyword">int8</span>(<span class="hljs-number">10</span>),<br>      <span class="hljs-keyword">int8</span>(<span class="hljs-number">20</span>),<br>      <span class="hljs-string">&quot;宝宝&quot;</span>,<br>   &#125;<br>fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;(m.a))<br>fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;(m.b))<br>fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;(m.c))<br>&#125;<br></code></pre></td></tr></table></figure><p>==在Go中恰到好处的内存对齐==</p></li><li><p>方法和接收者</p><ul><li>方法的定义格式<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(接收者变量 接受这类型)</span> 方法名<span class="hljs-params">(参数列表)</span> <span class="hljs-params">(返回参数)</span> &#123;</span><br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure></li><li>方法是作用于特定类型的函数</li></ul><p>==如果要修改接收者中的值，应该使用指针型接收者==</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123;<br>   name <span class="hljs-keyword">string</span><br>&#125;<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newDog</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">dog</span></span> &#123;<br>    <span class="hljs-keyword">return</span> dog&#123;<br>        name,<br>    &#125;<br>&#125;<br><span class="hljs-comment">//方法</span><br><span class="hljs-comment">//d为接收者，表示调用该方法的具体类型变量，多用类型名首字母小写表示</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dog)</span> <span class="hljs-title">wang</span><span class="hljs-params">()</span></span> &#123;<br>    d.name = <span class="hljs-string">&quot;bb&quot;</span><br>    fmt.Printf(<span class="hljs-string">&quot;%s:汪汪汪&quot;</span>, d.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    d1 := newDog(<span class="hljs-string">&quot;aa&quot;</span>)<br>    d1.wang()<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>疫情期间迪拜出差心得</title>
    <link href="/2021/05/20/%E6%97%A5%E8%AE%B0/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E8%BF%AA%E6%8B%9C%E5%87%BA%E5%B7%AE%E5%BF%83%E5%BE%97/"/>
    <url>/2021/05/20/%E6%97%A5%E8%AE%B0/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E8%BF%AA%E6%8B%9C%E5%87%BA%E5%B7%AE%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<ul><li><h5 id="今天是一个特殊的日子520，没有花时间在学习新技术上。我身处在7000km之外的迪拜，这是我第二次来迪拜出差，第一次刚好是武汉封城前。"><a href="#今天是一个特殊的日子520，没有花时间在学习新技术上。我身处在7000km之外的迪拜，这是我第二次来迪拜出差，第一次刚好是武汉封城前。" class="headerlink" title="今天是一个特殊的日子520，没有花时间在学习新技术上。我身处在7000km之外的迪拜，这是我第二次来迪拜出差，第一次刚好是武汉封城前。"></a>今天是一个特殊的日子520，没有花时间在学习新技术上。我身处在7000km之外的迪拜，这是我第二次来迪拜出差，第一次刚好是武汉封城前。</h5></li><li><h5 id="做迪拜智慧交通系统-ITS-已经快3年了，项目基本接近尾期，虽然国外疫情情况并不乐观，加上印度疫情大爆发，也许中国是世界上最安全的地方，但是出于对项目的责任心，以及希望它能成为一个很成功的项目，我还是决绝的来出差了。"><a href="#做迪拜智慧交通系统-ITS-已经快3年了，项目基本接近尾期，虽然国外疫情情况并不乐观，加上印度疫情大爆发，也许中国是世界上最安全的地方，但是出于对项目的责任心，以及希望它能成为一个很成功的项目，我还是决绝的来出差了。" class="headerlink" title="做迪拜智慧交通系统(ITS)已经快3年了，项目基本接近尾期，虽然国外疫情情况并不乐观，加上印度疫情大爆发，也许中国是世界上最安全的地方，但是出于对项目的责任心，以及希望它能成为一个很成功的项目，我还是决绝的来出差了。"></a>做迪拜智慧交通系统(ITS)已经快3年了，项目基本接近尾期，虽然国外疫情情况并不乐观，加上印度疫情大爆发，也许中国是世界上最安全的地方，但是出于对项目的责任心，以及希望它能成为一个很成功的项目，我还是决绝的来出差了。</h5></li><li><h5 id="2021年4月10号从成都飞广州再飞迪拜，到现在已经将近1个半月，回国航班的熔断机制很严，回国绿码审核也越来越严。领事馆发现有些人找人代核酸检测，于是加强了迪拜的核算检测，规定了指定监测点，要做2次检测，一次是登机前14天检测pcr和igm，一次是登机前48小时检测pcr和igm，还必须是2家不同的检测医院，一旦有一次或者一项不合格，就不会发放绿码。于是我比在武汉封城时候更小心，出门不脱口罩，买的吃的必定要消毒，回来对鞋底和身上消毒，勤洗手，非常小心翼翼，生怕一丝不注意就中招了（虽然出国前接种了疫苗）。由于本身有鼻炎，这边房间里没有新风，空气不太好，已经1年没犯过了，这是却复发了，引发喉咙也稍微有些痒（错觉以为自己不小心中了），不过自己心态还比较好（这时候怎么能过分吓自己呢）。终于熬到了5月20号，做第二次检测，上午10点做完，回到酒店从12点开始刷邮箱。这时候不得不说等待的时间真的很折磨人，真的很害怕结果不对，终于14点53分收到了pcr的阴性检测报告，整个人瞬间释怀了，心里的大石头落下了一半。继续刷邮箱，听说igm才是真正压审核的边界，然而到18点还是没有任何消息，心想还是要吃晚饭嘛，于是捣鼓了一下，看看电影吃个晚饭。收拾完餐具，刷了一会儿小红书，突然弹出一个邮件，我心知这是我在等的，我立马切换app，打开邮箱，结果阴性（虽然这结果就该这样，但是我真的心里狂喜啊）。赶紧的按照其他回国人员出的攻略进小程序申请绿码，经过35分钟的等待，绿码下来了，整个人如释负重啊！！！！这是我520收获的最大的礼物，没有之一。经过一个半月的实践，说明中国的疫苗真真切切的有效。"><a href="#2021年4月10号从成都飞广州再飞迪拜，到现在已经将近1个半月，回国航班的熔断机制很严，回国绿码审核也越来越严。领事馆发现有些人找人代核酸检测，于是加强了迪拜的核算检测，规定了指定监测点，要做2次检测，一次是登机前14天检测pcr和igm，一次是登机前48小时检测pcr和igm，还必须是2家不同的检测医院，一旦有一次或者一项不合格，就不会发放绿码。于是我比在武汉封城时候更小心，出门不脱口罩，买的吃的必定要消毒，回来对鞋底和身上消毒，勤洗手，非常小心翼翼，生怕一丝不注意就中招了（虽然出国前接种了疫苗）。由于本身有鼻炎，这边房间里没有新风，空气不太好，已经1年没犯过了，这是却复发了，引发喉咙也稍微有些痒（错觉以为自己不小心中了），不过自己心态还比较好（这时候怎么能过分吓自己呢）。终于熬到了5月20号，做第二次检测，上午10点做完，回到酒店从12点开始刷邮箱。这时候不得不说等待的时间真的很折磨人，真的很害怕结果不对，终于14点53分收到了pcr的阴性检测报告，整个人瞬间释怀了，心里的大石头落下了一半。继续刷邮箱，听说igm才是真正压审核的边界，然而到18点还是没有任何消息，心想还是要吃晚饭嘛，于是捣鼓了一下，看看电影吃个晚饭。收拾完餐具，刷了一会儿小红书，突然弹出一个邮件，我心知这是我在等的，我立马切换app，打开邮箱，结果阴性（虽然这结果就该这样，但是我真的心里狂喜啊）。赶紧的按照其他回国人员出的攻略进小程序申请绿码，经过35分钟的等待，绿码下来了，整个人如释负重啊！！！！这是我520收获的最大的礼物，没有之一。经过一个半月的实践，说明中国的疫苗真真切切的有效。" class="headerlink" title="2021年4月10号从成都飞广州再飞迪拜，到现在已经将近1个半月，回国航班的熔断机制很严，回国绿码审核也越来越严。领事馆发现有些人找人代核酸检测，于是加强了迪拜的核算检测，规定了指定监测点，要做2次检测，一次是登机前14天检测pcr和igm，一次是登机前48小时检测pcr和igm，还必须是2家不同的检测医院，一旦有一次或者一项不合格，就不会发放绿码。于是我比在武汉封城时候更小心，出门不脱口罩，买的吃的必定要消毒，回来对鞋底和身上消毒，勤洗手，非常小心翼翼，生怕一丝不注意就中招了（虽然出国前接种了疫苗）。由于本身有鼻炎，这边房间里没有新风，空气不太好，已经1年没犯过了，这是却复发了，引发喉咙也稍微有些痒（错觉以为自己不小心中了），不过自己心态还比较好（这时候怎么能过分吓自己呢）。终于熬到了5月20号，做第二次检测，上午10点做完，回到酒店从12点开始刷邮箱。这时候不得不说等待的时间真的很折磨人，真的很害怕结果不对，终于14点53分收到了pcr的阴性检测报告，整个人瞬间释怀了，心里的大石头落下了一半。继续刷邮箱，听说igm才是真正压审核的边界，然而到18点还是没有任何消息，心想还是要吃晚饭嘛，于是捣鼓了一下，看看电影吃个晚饭。收拾完餐具，刷了一会儿小红书，突然弹出一个邮件，我心知这是我在等的，我立马切换app，打开邮箱，结果阴性（虽然这结果就该这样，但是我真的心里狂喜啊）。赶紧的按照其他回国人员出的攻略进小程序申请绿码，经过35分钟的等待，绿码下来了，整个人如释负重啊！！！！这是我520收获的最大的礼物，没有之一。经过一个半月的实践，说明中国的疫苗真真切切的有效。"></a>2021年4月10号从成都飞广州再飞迪拜，到现在已经将近1个半月，回国航班的熔断机制很严，回国绿码审核也越来越严。领事馆发现有些人找人代核酸检测，于是加强了迪拜的核算检测，规定了指定监测点，要做2次检测，一次是登机前14天检测pcr和igm，一次是登机前48小时检测pcr和igm，还必须是2家不同的检测医院，一旦有一次或者一项不合格，就不会发放绿码。于是我比在武汉封城时候更小心，出门不脱口罩，买的吃的必定要消毒，回来对鞋底和身上消毒，勤洗手，非常小心翼翼，生怕一丝不注意就中招了（虽然出国前接种了疫苗）。由于本身有鼻炎，这边房间里没有新风，空气不太好，已经1年没犯过了，这是却复发了，引发喉咙也稍微有些痒（错觉以为自己不小心中了），不过自己心态还比较好（这时候怎么能过分吓自己呢）。终于熬到了5月20号，做第二次检测，上午10点做完，回到酒店从12点开始刷邮箱。这时候不得不说等待的时间真的很折磨人，真的很害怕结果不对，终于14点53分收到了pcr的阴性检测报告，整个人瞬间释怀了，心里的大石头落下了一半。继续刷邮箱，听说igm才是真正压审核的边界，然而到18点还是没有任何消息，心想还是要吃晚饭嘛，于是捣鼓了一下，看看电影吃个晚饭。收拾完餐具，刷了一会儿小红书，突然弹出一个邮件，我心知这是我在等的，我立马切换app，打开邮箱，结果阴性（虽然这结果就该这样，但是我真的心里狂喜啊）。赶紧的按照其他回国人员出的攻略进小程序申请绿码，经过35分钟的等待，绿码下来了，整个人如释负重啊！！！！这是我520收获的最大的礼物，没有之一。经过一个半月的实践，说明中国的疫苗真真切切的有效。</h5></li><li><h5 id="我为项目卖力，我给公司卖命，希望一切都值得；不过对于我自己来说，我的这份责任心做到了！"><a href="#我为项目卖力，我给公司卖命，希望一切都值得；不过对于我自己来说，我的这份责任心做到了！" class="headerlink" title="我为项目卖力，我给公司卖命，希望一切都值得；不过对于我自己来说，我的这份责任心做到了！"></a>我为项目卖力，我给公司卖命，希望一切都值得；不过对于我自己来说，我的这份责任心做到了！</h5></li></ul>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-defer</title>
    <link href="/2021/05/19/go%E5%9F%BA%E7%A1%80/04defer/"/>
    <url>/2021/05/19/go%E5%9F%BA%E7%A1%80/04defer/</url>
    
    <content type="html"><![CDATA[<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2Fb57c9724cf9167764d0eaf2abc402031.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1623949493&t=362c1a0f03eb1f6eee0a66d2076fe3fe" width="400px" height="150px" style="box-shadow: 0 0 0px"><ol><li>defer是什么？<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">延迟执行,后进先出<br></code></pre></td></tr></table></figure></li><li>defer的执行时机:<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">return</span>语句在底层并不是原子操作，分给返回值赋值和RET指令两步；<br><span class="hljs-keyword">defer</span>语句在<span class="hljs-number">2</span>者之间执行。<br></code></pre></td></tr></table></figure></li><li>Demo：<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>函数没有声明返回值变量：<br><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>.先给返回值开辟一个空间存了一份<span class="hljs-number">5</span>，作为返回值;<br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.defer修改x<br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>.执行ret指令，返回返回值<br><span class="hljs-keyword">func</span> d1() int&#123;<br>   x := <span class="hljs-number">5</span><br>   defer <span class="hljs-keyword">func</span>() &#123;<br>       x++ <span class="hljs-regexp">//</span>修改的是x，但是返回值不是x<br>   &#125;()<br>   return x <span class="hljs-regexp">//</span><span class="hljs-number">1</span>.返回值赋值 <span class="hljs-number">2</span>.defer <span class="hljs-number">3</span>.<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//函数声明返回值变量：</span><br><span class="hljs-comment">// 1.声明已经给返回值x开辟了空间，赋值返回值x=5;</span><br><span class="hljs-comment">// 2.defer修改x，x=6</span><br><span class="hljs-comment">// 3.执行ret指令，返回返回值x=6</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">d2</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span>&#123;<br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       x++<br>   &#125;()<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> <span class="hljs-comment">//返回值是x = 6</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//函数声明返回值变量：</span><br><span class="hljs-comment">// 1.声明已经给返回值y开辟了空间，赋值返回值y=5;</span><br><span class="hljs-comment">// 2.defer修改x，x=6</span><br><span class="hljs-comment">// 3.执行ret指令，返回返回值y=5</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">d3</span><span class="hljs-params">()</span> <span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span></span>&#123;<br>   x := <span class="hljs-number">5</span><br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       x++ <span class="hljs-comment">//修改的是x</span><br>   &#125;()<br>   <span class="hljs-keyword">return</span> x <span class="hljs-comment">//返回值 = y = x = 5</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//函数声明返回值变量：</span><br><span class="hljs-comment">// 1.声明已经给返回值x开辟了空间，赋值返回值x=5;</span><br><span class="hljs-comment">// 2.defer修改x的副本，x副本=6</span><br><span class="hljs-comment">// 3.执行ret指令，返回返回值y=5</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">d4</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span>&#123;<br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>       x++ <span class="hljs-comment">//改变的是函数中x的副本</span><br>   &#125;(x)<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> <span class="hljs-comment">//返回值 = x = 5</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//函数声明返回值变量名：</span><br><span class="hljs-comment">// 1.声明已经给返回值x开辟了空间，赋值返回值x=5;</span><br><span class="hljs-comment">// 2.defer 根据指针地址来修改x，x=6</span><br><span class="hljs-comment">// 3.执行ret指令，返回返回值x=6</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">d5</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span>&#123;<br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x *<span class="hljs-keyword">int</span>)</span></span> &#123;<br>       (*x)++ <span class="hljs-comment">//改变的是函数中x的副本</span><br>   &#125;(&amp;x)<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> <span class="hljs-comment">//返回值 = x = 6</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>面试题：<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> calc(index string, a, b int) int &#123;<br>   ret := a + b<br>   fmt.Println(index, a, b, ret)<br>   return ret<br>&#125;<br><span class="hljs-keyword">func</span> main()  &#123;<br>   a := <span class="hljs-number">1</span><br>   b := <span class="hljs-number">2</span><br>   defer  calc(<span class="hljs-string">&quot;1&quot;</span>, a, calc(<span class="hljs-string">&quot;10&quot;</span>, a, b))<br>   a = <span class="hljs-number">0</span><br>   defer  calc(<span class="hljs-string">&quot;2&quot;</span>, a, calc(<span class="hljs-string">&quot;20&quot;</span>, a, b))<br>   b = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-regexp">//</span>解题分析<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>. a:=<span class="hljs-number">1</span><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>. b:=<span class="hljs-number">2</span><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>. defer  calc(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>, calc(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-regexp">//</span><span class="hljs-number">4</span>. calc(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> 打印 <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span><span class="hljs-number">5</span>. defer  calc(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><span class="hljs-regexp">//</span><span class="hljs-number">6</span>. a=<span class="hljs-number">0</span><br><span class="hljs-regexp">//</span><span class="hljs-number">7</span>. defer  calc(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">0</span>, calc(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<br><span class="hljs-regexp">//</span><span class="hljs-number">8</span>. calc(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> <span class="hljs-regexp">//</span> 打印 <span class="hljs-string">&quot;20&quot;</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span><span class="hljs-number">9</span>. defer  calc(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br><span class="hljs-regexp">//</span><span class="hljs-number">10</span>.b=<span class="hljs-number">1</span><br><span class="hljs-regexp">//</span><span class="hljs-number">11</span>.calc(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> 打印 <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span><span class="hljs-number">12</span>.calc(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-regexp">//</span> 打印 <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>/*最终结果为<br>  <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br>  <span class="hljs-string">&quot;20&quot;</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br>  <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br>  <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>*/<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-闭包</title>
    <link href="/2021/05/18/go%E5%9F%BA%E7%A1%80/03%E9%97%AD%E5%8C%85/"/>
    <url>/2021/05/18/go%E5%9F%BA%E7%A1%80/03%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2Fb57c9724cf9167764d0eaf2abc402031.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1623949493&t=362c1a0f03eb1f6eee0a66d2076fe3fe" width="400px" height="150px" style="box-shadow: 0 0 0px">1. 闭包是什么？   <figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">闭包是一个函数，这个函数包含了他外部作用域的一个变量<br></code></pre></td></tr></table></figure>2. demo:   <figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>             x += y<br>             <span class="hljs-keyword">return</span> x<br>           &#125;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>     ret := adder(<span class="hljs-number">100</span>)<br>     ret2 := ret(<span class="hljs-number">200</span>)<br>     fmt.Println(ret2)<br>&#125;<br></code></pre></td></tr></table></figure>3. 底层原理：   <figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 函数可以作为返回值<br><span class="hljs-bullet">2.</span> 函数内部查找变量的顺序，先在自己内部找，找不到往外层找<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-指针</title>
    <link href="/2021/05/18/go%E5%9F%BA%E7%A1%80/02%E6%8C%87%E9%92%88/"/>
    <url>/2021/05/18/go%E5%9F%BA%E7%A1%80/02%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2Fb57c9724cf9167764d0eaf2abc402031.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1623949493&t=362c1a0f03eb1f6eee0a66d2076fe3fe" width="400px" height="150px" style="box-shadow: 0 0 0px"><ol><li>变量、指针地址、指针变量、取地址、取值的相互关系：<ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量</li><li>指针变量的值是指针地址</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>变量<br>n := <span class="hljs-number">18</span><br><span class="hljs-regexp">//</span>指针变量<br>p := &amp;n<br><span class="hljs-regexp">//</span>新变量，值为原变量的值<br>m := *p<br></code></pre></td></tr></table></figure></li></ul></li><li>相关函数<ul><li>new：很少用，一般用来给基本数据类型申请内存（string/int…），返回对应类型的指针（*string/*int）<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//new 函数申请一个内存地址</span><br><span class="hljs-built_in">var</span> a2 = <span class="hljs-keyword">new</span>(<span class="hljs-built_in">int</span>)<br><span class="hljs-comment">//赋值</span><br>*a2 =<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li>make：用于内存分配，用于slice，map以及chan申请内存，返回对应这三个类型本身（引用类型）</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-切片</title>
    <link href="/2021/05/18/go%E5%9F%BA%E7%A1%80/01%E5%88%87%E7%89%87/"/>
    <url>/2021/05/18/go%E5%9F%BA%E7%A1%80/01%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2Fb57c9724cf9167764d0eaf2abc402031.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1623949493&t=362c1a0f03eb1f6eee0a66d2076fe3fe" width="400px" height="150px" style="box-shadow: 0 0 0px"><ol><li><ul><li>切片不保存具体的值，</li><li>切片对应一个底层数组</li><li>底层数组占用一块连续的内存</li></ul></li><li>切片的容量是指底层数组的第一个元素到最后一个元素的数量</li><li>切片是引用类型，指向了底层的一个数组</li><li>切片的本质：就是一个框，框住了一块连续的内存，属于引用类型</li><li>相关函数<ul><li>切片初始化<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s1</span> = []int&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure></li><li>由数组得到切片<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">a1 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>s3 := a1[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">//切割0-4，左包含右不包含</span><br></code></pre></td></tr></table></figure></li><li>make<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建一个长度为5，容量为10的切片</span><br><span class="hljs-comment">//int默认为0，string默认为“”</span><br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li><li>append<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s1 := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;北京&quot;</span>,<span class="hljs-string">&quot;上海&quot;</span>,<span class="hljs-string">&quot;深圳&quot;</span>&#125;<br><span class="hljs-comment">//如果超出切片的容量，数组扩容为原来的两倍</span><br>s2 := <span class="hljs-built_in">append</span>(s1, <span class="hljs-string">&quot;成都&quot;</span>)<br><span class="hljs-comment">//如果超出切片的容量，扩容一倍也不够，数组直接扩容到最终的大小</span><br>s3 := <span class="hljs-built_in">append</span>(s1, <span class="hljs-string">&quot;成都&quot;</span>,<span class="hljs-string">&quot;北京1&quot;</span>,<span class="hljs-string">&quot;上海1&quot;</span>,<span class="hljs-string">&quot;深圳1&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>copy<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">a1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">//创建新切片，底层新数组</span><br>a3 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">//a1,a3对应2个数组，通过copy只是复制了值，不会改变底层数组的内存地址</span><br><span class="hljs-built_in">copy</span>(a3, a1)<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
